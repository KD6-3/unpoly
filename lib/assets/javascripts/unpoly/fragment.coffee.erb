###**
Fragment update API
===================
  
The `up.fragment` module exposes a high-level Javascript API to [update](/up.replace) or
[destroy](/up.destroy) page fragments.

Fragments are [compiled](/up.compiler) elements that can be updated from a server URL.
They also exist on a layer (page, modal, popup).

Most of Unpoly's functionality (like [fragment links](/up.link) or [modals](/up.modal))
is built from `up.fragment` functions. You may use them to extend Unpoly from your
[custom Javascript](/up.syntax).

@module up.fragment
###
up.fragment = do ->
  
  u = up.util
  e = up.element

  ###**
  Returns the URL the given element was retrieved from.

  @function up.fragment.source
  @param {Array<string>} config.mainTargets
  @param {Array<string>} config.resetTargets
  @return {Array<RegExp>} config.targetClasses
  @experimental
  ###
  config = new up.Config ->
    u.literal
      # Users who are not using layers will prefer settings default targets
      # as up.fragment.config.mainTargets instead of up.layer.config.any.mainTargets.
      get_mainTargets: -> up.layer.config.any.mainTargets
      resetTargets: ['body']
      badTargetClasses: [/^up-/]
  up.legacy.renamedProperty(config, 'fallbacks', 'mainTargets')

  reset = ->
    config.reset()

  setSource = (element, sourceURL) ->
    element.upSource = sourceURL

  ###**
  Returns the URL the given element was retrieved from.

  @function up.fragment.source
  @param {string|Element|jQuery} target
  @param {Object} options
  @return {string|undefined}
  @experimental
  ###
  source = (args...) ->
    options = parseTargetAndOptions(args)
    element = getOne(options.target, options)

    if url = element.upSource
      url
    else if parent = element.parentElement
      source(parent)


  ###**
  Replaces elements on the current page with corresponding elements
  from a new page fetched from the server.

  The current and new elements must both match the given CSS selector.

  The unobtrusive variant of this is the [`a[up-target]`](/a-up-target) selector.

  \#\#\# Example

  Let's say your current HTML looks like this:

      <div class="one">old one</div>
      <div class="two">old two</div>

  We now replace the second `<div>`:

      up.replace('.two', '/new')

  The server renders a response for `/new`:

      <div class="one">new one</div>
      <div class="two">new two</div>

  Unpoly looks for the selector `.two` in the response and [implants](/up.extract) it into
  the current page. The current page now looks like this:

      <div class="one">old one</div>
      <div class="two">new two</div>

  Note how only `.two` has changed. The update for `.one` was
  discarded, since it didn't match the selector.

  \#\#\# Appending or prepending instead of replacing

  By default Unpoly will replace the given selector with the same
  selector from a freshly fetched page. Instead of replacing you
  can *append* the loaded content to the existing content by using the
  `:after` pseudo selector. In the same fashion, you can use `:before`
  to indicate that you would like the *prepend* the loaded content.

  A practical example would be a paginated list of items:

      <ul class="tasks">
        <li>Wash car</li>
        <li>Purchase supplies</li>
        <li>Fix tent</li>
      </ul>

  In order to append more items from a URL, replace into
  the `.tasks:after` selector:

      up.replace('.tasks:after', '/page/2')

  \#\#\# Setting the window title from the server

  If the `replace` call changes history, the document title will be set
  to the contents of a `<title>` tag in the response.

  The server can also change the document title by setting
  an `X-Up-Title` header in the response.

  \#\#\# Optimizing response rendering

  The server is free to optimize Unpoly requests by only rendering the HTML fragment
  that is being updated. The request's `X-Up-Target` header will contain
  the CSS selector for the updating fragment.

  If you are using the `unpoly-rails` gem you can also access the selector via
  `up.target` in all controllers, views and helpers.

  \#\#\# Events

  Unpoly will emit [`up:fragment:destroyed`](/up:fragment:destroyed) on the element
  that was replaced and [`up:fragment:inserted`](/up:fragment:inserted) on the new
  element that replaces it.

  @function up.render
  @param {string|Element|jQuery} [options.target]
    The CSS selector to update. You can also pass a DOM element or jQuery element
    here, in which case a selector will be inferred from the element's class and ID.
  @param {string} [options.url]
    The URL to fetch from the server.
  @param {string} [options.fragment]
    TODO: Docs
  @param {string} [options.document]
    TODO: Docs
  @param {string} [options.failOptions]
    TODO: Document failOptions and the general behavior of fail options
  @param {string} [options.fallback]
    The selector to update when the original target was not found in the page.
  @param {string} [options.title]
    The document title after the replacement.

    If the call pushes an history entry and this option is missing, the title is extracted from the response's `<title>` tag.
    You can also pass `false` to explicitly prevent the title from being updated.
  @param {string} [options.method='get']
    The HTTP method to use for the request.
  @param {Object|FormData|string|Array} [options.params]
    [Parameters](/up.Params) that should be sent as the request's payload.
  @param {string} [options.transition='none']
  @param {string|boolean} [options.history=true]
    If a string is given, it is used as the URL the browser's location bar and history.
    If omitted or true, the `url` argument will be used.
    If set to `false`, the history will remain unchanged.
  @param {boolean|string} [options.reveal=false]
    Whether to [reveal](/up.reveal) the new fragment.

    You can also pass a CSS selector for the element to reveal.
  @param {number} [options.revealPadding]

  @param {boolean} [options.restoreScroll=false]
    If set to true, Unpoly will try to restore the scroll position
    of all the viewports around or below the updated element. The position
    will be reset to the last known top position before a previous
    history change for the current URL.
  @param {boolean} [options.cache]
    Whether to use a [cached response](/up.proxy) if available.
  @param {Object} [options.headers={}]
    An object of additional header key/value pairs to send along
    with the request.
  @param {Element|jQuery} [options.origin]
    The element that triggered the replacement.

    The element's selector will be substituted for the `&` shorthand in the target selector ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).
  @param {string} [options.layer='auto']
    TODO: Docs for all layer-related options. However, opts for new layers we will document on up.layer.open().
  @param {boolean} [options.keep=true]
    Whether this replacement will preserve [`[up-keep]`](/up-keep) elements.
  @param {boolean} [options.hungry=true]
    Whether this replacement will update [`[up-hungry]`](/up-hungry) elements.

  @return {Promise}
    A promise that is fulfilled when the page has been updated.

    If the update is animated, the promise will be resolved *before* the existing element was
    removed from the DOM tree. The old element will be marked with the `.up-destroying` class
    and removed once the animation finishes. To run code after the old element was removed,
    pass an `{ onMotionEnd }` callback.
  @stable
  ###
  render = (args...) ->
    options = parseTargetAndOptions(args)

    options.hungry ?= true # preflight option has no failVariant
    options.keep ?= true
    options.failKeep ?= true
    options.focus ?= 'auto'

    # When preloading, disable all preflight side effects.
    if options.preload
      options.solo = false # preflight option has no failVariant
      options.confirm = false # preflight option has no failVariant
      options.feedback = false # preflight option has no failVariant

    # By default we consider every change to be a user-initiated navigation
    # that involves changing scroll positions, browser location, etc.
    # Developers can pass { navigate: false } to only update a fragment without
    # any other effects.
    navigate = options.navigate ? true # preflight option has no fail variant

    options.solo ?= navigate # preflight option has no failVariant
    options.feedback ?= navigate # preflight option has no failVariant
    options.peel ?= navigate
    options.failPeel ?= navigate
    options.reveal ?= navigate
    options.failReveal ?= navigate
    options.saveScroll ?= navigate
    options.failSaveScroll ?= navigate

    if navigate
      options.focus ?= 'auto'
    else
      # Only change this for non-default { navigate: false } option.
      # For the default option history should depend on the layer mode setting.
      options.history ?= false
      options.failHistory ?= false

    promise = up.browser.whenConfirmed(options)

    if guardEvent = options.guardEvent
      # Allow guard event handlers to manipulate options for the default behavior
      guardEvent.options = options
      promise = promise.then -> up.event.whenEmitted(options.origin, guardEvent)

    promise = promise.then ->
      if options.solo && !options.preload
        up.proxy.abort()
      up.feedback.aroundForOptions(options, (-> makeChangeNow(options)))

    return promise

  makeChangeNow = (options) ->
    if options.url
      return new up.Change.FromURL(options).executeAsync()
    else
      return new up.Change.FromContent(options).executeAsync()

  ###**
  This event is [emitted](/up.emit) when the server responds with the HTML, before
  the HTML is used to [change a fragment](/up.render).

  Event listeners may call `event.preventDefault()` on an `up:fragment:loaded` event
  to prevent any changes to the DOM and browser history. This is useful to detect
  an entirely different page layout (like a maintenance page or fatal server error)
  which should be open with a full page load:

      up.on('up:fragment:loaded', (event) => {
        let isMaintenancePage = event.response.getHeader('X-Maintenance')

        if (isMaintenancePage) {
          // Prevent the fragment update and don't update browser history
          event.preventDefault()

          // Make a full page load for the same request.
          event.request.loadPage()
        }
      })

  Instead of preventing the update, listeners may also access the `event.change` object
  to mutate options to the `up.render()` call that will process the server response.

  @param event.preventDefault()
    Event listeners may call this method to prevent the fragment change.
  @param {up.Request} event.request
    The original request to the server.
  @param {up.Response} event.response
    The server response.
  @param {Object} event.change
    Options for the `up.render()` call that will process the server response.
  @event up:fragment:loaded
  ###

  ###**
  Replaces elements on the current page with corresponding elements
  from a new page fetched from the server.

  @function up.replace
  @param {string|Element|jQuery} target
    The CSS selector to update. You can also pass a DOM element or jQuery element
    here, in which case a selector will be inferred from the element's class and ID.
  @param {string} url
    The URL to fetch from the server.
  @param {Object} [options]
    See `options` for `up.render()
  @return {Promise}
    A promise that is fulfilled when the page has been updated.
  @deprecated
    Use `up.render()` instead.
  @stable
  ###
  replace = (target, url, options) ->
    up.legacy.deprecated('up.replace(target, url)', 'up.render(target, { url })')
    return render(target, u.merge(options, { url }))

  ###**
  Updates a selector on the current page with the
  same selector from the given HTML string.

  \#\#\# Example

  Let's say your current HTML looks like this:

      <div class="one">old one</div>
      <div class="two">old two</div>

  We now replace the second `<div>`, using an HTML string
  as the source:

      html = '<div class="one">new one</div>' +
             '<div class="two">new two</div>';

      up.extract('.two', html)

  Unpoly looks for the selector `.two` in the strings and updates its
  contents in the current page. The current page now looks like this:

      <div class="one">old one</div>
      <div class="two">new two</div>

  Note how only `.two` has changed. The update for `.one` was
  discarded, since it didn't match the selector.

  @function up.extract
  @param {string|Element|jQuery} target
  @param {string} html
  @param {Object} [options]
    See options for [`up.render()`](/up.render).
  @return {Promise}
    A promise that will be fulfilled then the selector was updated.
  @stable
  ###
  extract = (target, document, options) ->
    up.legacy.deprecated('up.extract(target, document)', 'up.render(target, { document })')
    return render(target, u.merge(options, { document }))

  ###**
  Elements with an `up-keep` attribute will be persisted during
  [fragment updates](/a-up-target).

  For example:

      <audio up-keep src="song.mp3"></audio>

  The element you're keeping should have an umambiguous class name, ID or `up-id`
  attribute so Unpoly can find its new position within the page update.

  Emits events [`up:fragment:keep`](/up:fragment:keep) and [`up:fragment:kept`](/up:fragment:kept).

  \#\#\# Controlling if an element will be kept

  Unpoly will **only** keep an existing element if:

  - The existing element has an `up-keep` attribute
  - The response contains an element matching the CSS selector of the existing element
  - The matching element *also* has an `up-keep` attribute
  - The [`up:fragment:keep`](/up:fragment:keep) event that is [emitted](/up.emit) on the existing element
    is not prevented by a event listener.

  Let's say we want only keep an `<audio>` element as long as it plays
  the same song (as identified by the tag's `src` attribute).

  On the client we can achieve this by listening to an `up:keep:fragment` event
  and preventing it if the `src` attribute of the old and new element differ:

      up.compiler('audio', function(element) {
        element.addEventListener('up:fragment:keep', function(event) {
          if element.getAttribute('src') !== event.newElement.getAttribute('src') {
            event.preventDefault()
          }
        })
      })

  If we don't want to solve this on the client, we can achieve the same effect
  on the server. By setting the value of the `up-keep` attribute we can
  define the CSS selector used for matching elements.

      <audio up-keep="audio[src='song.mp3']" src="song.mp3"></audio>

  Now, if a response no longer contains an `<audio src="song.mp3">` tag, the existing
  element will be destroyed and replaced by a fragment from the response.

  @selector [up-keep]
  @param {string} up-on-keep
    Code to run before an existing element is kept during a page update.

    The code may use the variables `event` (see `up:fragment:keep`),
    `this` (the old fragment), `newFragment` and `newData`.
  @stable
  ###

  ###**
  This event is [emitted](/up.emit) before an existing element is [kept](/up-keep) during
  a page update.

  Event listeners can call `event.preventDefault()` on an `up:fragment:keep` event
  to prevent the element from being persisted. If the event is prevented, the element
  will be replaced by a fragment from the response.

  @event up:fragment:keep
  @param event.preventDefault()
    Event listeners may call this method to prevent the element from being preserved.
  @param {Element} event.target
    The fragment that will be kept.
  @param {Element} event.newFragment
    The discarded element.
  @param {Object} event.newData
    The value of the [`up-data`](/up-data) attribute of the discarded element,
    parsed as a JSON object.
  @stable
  ###

  ###**
  This event is [emitted](/up.emit) when an existing element has been [kept](/up-keep)
  during a page update.

  Event listeners can inspect the discarded update through `event.newElement`
  and `event.newData` and then modify the preserved element when necessary.

  @event up:fragment:kept
  @param {Element} event.target
    The fragment that has been kept.
  @param {Element} event.newFragment
    The discarded fragment.
  @param {Object} event.newData
    The value of the [`up-data`](/up-data) attribute of the discarded fragment,
    parsed as a JSON object.
  @stable
  ###

  ###**
  Compiles a page fragment that has been inserted into the DOM
  by external code.

  **As long as you manipulate the DOM using Unpoly, you will never
  need to call this method.** You only need to use `up.hello()` if the
  DOM is manipulated without Unpoly' involvement, e.g. by setting
  the `innerHTML` property or calling jQuery methods like
  `html`, `insertAfter` or `appendTo`:

      element = document.createElement('div')
      element.innerHTML = '... HTML that needs to be activated ...'
      up.hello(element)

  This function emits the [`up:fragment:inserted`](/up:fragment:inserted)
  event.

  @function up.hello
  @param {Element|jQuery} target
  @param {Element|jQuery} [options.origin]
  @return {Element}
    The compiled element
  @stable
  ###
  hello = (element, options = {}) ->
    # If passed a selector, up.fragment.get() will prefer a match on the current layer.
    element = getOne(element)

    # Callers may pass descriptions of child elements that were [kept](/up-keep)
    # as { options.keepPlans }. For these elements up.hello() emits an event
    # up:fragment:kept instead of up:fragment:inserted.
    #
    # We will also pass an array of kept child elements to up.hello() as { skip }
    # so they won't be compiled a second time.
    keepPlans = options.keepPlans || []
    skip = keepPlans.map (plan) ->
      emitFragmentKept(plan)
      return plan.oldElement

    up.syntax.compile(element, { skip, layer: options.layer })
    emitFragmentInserted(element, options)

    return element

  ###**
  When any page fragment has been [inserted or updated](/up.replace),
  this event is [emitted](/up.emit) on the fragment.

  If you're looking to run code when a new fragment matches
  a selector, use `up.compiler()` instead.

  \#\#\# Example

      up.on('up:fragment:inserted', function(event, fragment) {
        console.log("Looks like we have a new %o!", fragment)
      })

  @event up:fragment:inserted
  @param {Element} event.target
    The fragment that has been inserted or updated.
  @stable
  ###
  emitFragmentInserted = (element, options) ->
    up.emit element, 'up:fragment:inserted',
      log: ['Inserted fragment %o', element]
      origin: options.origin

  emitFragmentKeep = (keepPlan) ->
    log = ['Keeping fragment %o', keepPlan.oldElement]
    callback = e.callbackAttr(keepPlan.oldElement, 'up-on-keep', ['newFragment', 'newData'])
    emitFromKeepPlan(keepPlan, 'up:fragment:keep', { log, callback })

  emitFragmentKept = (keepPlan) ->
    log = ['Kept fragment %o', keepPlan.oldElement]
    emitFromKeepPlan(keepPlan, 'up:fragment:kept', { log })

  emitFromKeepPlan = (keepPlan, eventType, emitDetails) ->
    keepable = keepPlan.oldElement

    event = up.event.build(eventType,
      newFragment: keepPlan.newElement
      newData: keepPlan.newData
    )

    up.emit(keepable, event, emitDetails)

  emitFragmentDestroyed = (fragment, options) ->
    log = options.log ? ['Destroyed fragment %o', fragment]
    parent = options.parent or up.fail("Missing { parent } option")
    up.emit(parent, 'up:fragment:destroyed', { fragment, parent, log })

  isDestroying = (element) ->
    !!e.closest(element, '.up-destroying')

  ###**
  Returns the first element matching the given selector, but
  ignores elements that are being [destroyed](/up.destroy) or that are being
  removed by a [transition](/up.morph).

  Returns `undefined` if no element matches these conditions.

  \#\#\# Example

  To select the first element with the selector `.foo`:

      var fooInModal = up.fragment.get('.foo')

  You may also pass a `{ layer }` option to only match elements witin a layer:

      var fooInModal = up.fragment.get('.foo', { layer: 'modal' })

  You may also pass a root element as a first argument:

      var container = up.fragment.get('.container')
      var fooInContainer = up.fragment.get(container, '.foo')

  \#\#\# Similar features

  - The [`.up-destroying`](/up-destroying) class is assigned to elements during their removal animation.
  - The [`up.element.get()`](/up.element.get) function simply returns the first element matching a selector
    without further filtering.

  @function up.fragment.get
  @param {Element|jQuery} [root=document]
    The root element for the search. Only the root's children will be matched.

    May be omitted to search through all elements in the `document`.
  @param {string} selector
    The selector to match
  @param {string} [options.layer='auto']
    The name of the layer in which to find the element.

    Valid values are `'auto'`, `'page'`, `'modal'` and `'popup'`.
  @param {string|Element|jQuery} [options.origin]
    An second element or selector that can be referenced as `&` in the first selector:

        var input = document.querySelector('input.email')
        up.fragment.get('fieldset:has(&)', { origin: input }) // returns the <fieldset> containing input
  @return {Element|undefined}
    The first element that is neither a ghost or being destroyed,
    or `undefined` if no such element was found.
  @experimental
  ###
  getOne = (args...) ->
    # TODO: Change docs
    getAll(args...)[0]

  # TODO: Docs for up.fragment.all
  getAll = (args...) ->
    options = u.extractOptions(args)
    selectorOrElement = args.pop()

    if u.isElementish(selectorOrElement)
      # up.fragment.all([root], element, [options]) should just return [element].
      # The given root and options are ignored. We also don't check if it's destroying.
      # We do use e.get() to unwrap a jQuery collection.
      return [e.get(selectorOrElement)]
    else
      selector = resolveTarget(selectorOrElement, options)

      if rootElement = args[0]
        # up.fragment.all(rootElement, selector) should find selector within
        # the descendants of rootElement.
        selectFn = if options.subtree then e.subtree else e.all
        candidates = selectFn(rootElement, selector)

        # Check if the root element has a child layer whose elements we need
        # to exclude fromt the matches.
        if childLayerElement = e.get(rootElement, up.layer.anySelector())
          # Since we have already have the child layer's element, we're using the native
          # Element#contains() instead of the slower up.Element#contains().
          candidates = u.reject(candidates, (candidate) -> childLayerElement.contains(candidate))

      else
        # up.fragment.all(selector, [options]) should lookup the selector
        # in all layers (prefering the current layer), or in options.layer.
        # Note that options.layer might resolve to more than one layer, e.g.
        # with { layer: 'ancestor' } or { layer: 'any' }.
        layers = up.layer.getAll(options)
        candidates = u.flatMap layers, (layer) -> getAll(layer.element, selector, subtree: true)

      unless options.destroying
        candidates = u.reject(candidates, isDestroying)

      return candidates

  getSubtree = (element, selector, options = {}) ->
    getAll(element, selector, u.merge(options, subtree: true))

#  ###**
#  Returns the first element that matches the selector by testing the element itself
#  and traversing up through ancestors in element's layers.
#
#  `up.fragment.closest()` will only match elements in the same [layer](/up.layer) as element.
#  To match ancestors regardless of layers, use `up.element.closest()`.
#
#  @function up.fragment.closest
#  @param {Element} element
#    The element on which to start the search.
#  @param {string} selector
#    The CSS selector to match.
#  @return {Element|null|undefined} element
#    The matching element.
#
#    Returns `null` or `undefined` if no element matches in the same layer.
#  @experimental
#  ###
  closest = (element, selector) ->
    match = e.closest(element, selector)
    if match && (up.layer.get(match) == up.layer.get(element)) && !isDestroying(match)
      return match

  ###**
  Destroys the given element or selector.

  Takes care that all [`up.compiler()`](/up.compiler) destructors, if any, are called.

  The element is removed from the DOM.
  Note that if you choose to animate the element removal using `options.animate`,
  the element won't be removed until after the animation has completed.

  Emits events [`up:fragment:destroyed`](/up:fragment:destroyed).

  @function up.destroy
  @param {string|Element|jQuery} target
  @param {string} [options.location]
    A URL that will be pushed as a new history entry when the element was destroyed.
  @param {string} [options.title]
    The document title to set after the element was destroyed.
  @param {string|Function(element, options): Promise} [options.animation='none']
    The animation to use before the element is removed from the DOM.
  @param {number} [options.duration]
    The duration of the animation. See [`up.animate()`](/up.animate).
  @param {number} [options.delay]
    The delay before the animation starts. See [`up.animate()`](/up.animate).
  @param {string} [options.easing]
    The timing function that controls the animation's acceleration. [`up.animate()`](/up.animate).
  @param {Function} [options.onMotionEnd]
    A callback that is run when the destroy animation has ended and
    the element was removed from the DOM.
  @return {Promise}
    A promise that is fulfilled when the element has been destroyed.

    If the destruction is animated, the promise will be resolved *before* the element was
    removed from the DOM tree. The element will be marked with the `.up-destroying` class
    and removed once the animation finishes. To run code after the element was removed,
    pass an `{ onMotionEnd }` callback.
  @stable
  ###
  destroy = (args...) ->
    options = parseTargetAndOptions(args)

    if options.element = getOne(options.target, options)
      return new up.Change.DestroyFragment(options).executeAsync()
    else
      return Promise.resolve()

  parseTargetAndOptions = (args) ->
    options = u.parseArgIntoOptions(args, 'target')
    options

  ###**
  Elements are assigned the `.up-destroying` class before they are [destroyed](/up.destroy)
  or while they are being removed by a [transition](/up.morph).

  If the removal is animated, the class is assigned before the animation starts.

  To select an element while ignoring elements that are being destroyed,
  see the [`up.fragment.get()`](/up.fragment.get) function.

  @selector .up-destroying
  @stable
  ###
  markFragmentAsDestroying = (element) ->
    element.classList.add('up-destroying')
    element.setAttribute('aria-hidden', 'true')

  ###**
  This event is [emitted](/up.emit) after a page fragment was [destroyed](/up.destroy) and removed from the DOM.

  If the destruction is animated, this event is emitted after the animation has ended.

  The event is emitted on the parent element of the fragment that was removed.

  @event up:fragment:destroyed
  @param {Element} event.fragment
    The detached element that has been removed from the DOM.
  @param {Element} event.parent
    The former parent element of the fragment that has now been detached from the DOM.
  @param {Element} event.target
    The former parent element of the fragment that has now been detached from the DOM.
  @stable
  ###

  ###**
  Replaces the given element with a fresh copy fetched from the server.

  \#\#\# Example

      up.on('new-mail', function() { up.reload('.inbox') })

  Unpoly remembers the URL from which a fragment was loaded, so you
  don't usually need to give an URL when reloading.

  @function up.reload
  @param {string|Element|jQuery} [target]
    The element that should be reloaded.

    If omitted, an element matching a selector in [`up.fragment.config.mainTargets`](/up.fragment.config#config.mainTargets)
    will be reloaded.
  @param {Object} [options]
    See options for `up.render()`
  @param {string} [options.url]
    The URL from which to reload the fragment.
    This defaults to the URL from which the fragment was originally loaded.
  @stable
  ###
  reload = (args...) ->
    options = parseTargetAndOptions(args)
    options.cache ?= false
    options.url ?= source(options.target)
    options.navigate ?= false
    return render(options)

  ###**
  Fetches this given URL with JavaScript and [replaces](/up.replace) the
  current `<body>` element with the response's `<body>` element.

  \#\#\# Example

  This would replace the current page with the response for `/users`:

      up.visit('/users')

  @function up.visit
  @param {string} url
    The URL to visit.
  @param {string} [options.target]
    The selector to replace.
  @param {Object} [options]
    See options for `up.render()`
  @stable
  ###
  visit = (url, options = {}) ->
    up.legacy.warn("up.visit(url) has been deprecated. Use up.render({ url }) instead.")
    up.render(u.merge(options, { url }))

  successKey = (key) ->
    return u.unprefixCamelCase(key, 'fail')

  failKey = (key) ->
    unless key.match(/^fail[A-Z]/)
      return u.prefixCamelCase(key, 'fail')

  ###**
  Returns a CSS selector that matches the given element as good as possible.

  To build the selector, the following element properties are used in decreasing
  order of priority:

  - The element's `[up-id]` attribute
  - The element's `[id]` attribute
  - The element's `[name]` attribute
  - The element's `[class]` names
  - The element's [`[aria-label]`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-label_attribute) attribute
  - The element's tag name

  \#\#\# Example

      element = document.createElement('span')
      element.className = 'klass'
      selector = up.fragment.toTarget(element) // returns '.klass'

  @function up.element.toTarget
  @param {string|Element|jQuery}
    The element for which to create a selector.
  @experimental
  ###
  toTarget = (element) ->
    if u.isString(element)
      return element

    # In case we're called called with a jQuery collection
    element = e.get(element)

    if e.isSingleton(element)
       return e.elementTagName(element)
     else if upId = element.getAttribute("up-id")
       return e.attributeSelector('up-id', upId)
     else if id = element.getAttribute("id")
       return e.idSelector(id)
     else if name = element.getAttribute("name")
       return e.attributeSelector('name', name)
     else if goodClass = u.find(element.classList, isGoodClassForTarget)
       return ".#{goodClass}"
     else if ariaLabel = element.getAttribute("aria-label")
       return e.attributeSelector('aria-label', ariaLabel)
     else
       return e.elementTagName(element)

  ###**
  Sets an unique identifier for this element.

  This identifier is used by `up.fragment.toSelector()`
  to create a CSS selector that matches this element precisely.

  If the element already has other attributes that make a good identifier,
  like a good `[id]` or `[class]` attribute, it is not necessary to
  also set `[up-id]`.

  \#\#\# Example

  Take this element:

      <a href="/">Homepage</a>

  Unpoly cannot generate a good CSS selector for this element:

      up.fragment.toTarget(element)
      // returns 'a'

  We can improve this by assigning an `[up-id]`:

      <a href="/" up-id="link-to-home">Open user 4</a>

  The attribute value is used to create a better selector:

      up.fragment.toTarget(element)
      // returns '[up-id="link-to-home"]'

  @selector [up-id]
  @param {string} up-id
    A string that uniquely identifies this element.
  @stable
  ###

  isGoodClassForTarget = (klass) ->
    return !u.some(config.badTargetClasses, (pattern) -> pattern.test(klass))

  resolveTarget = (target, options= {}) ->
    origin = options.origin

    target = target.replace '&', (match) ->
      if origin
        return toTarget(origin)
      else
        up.fail("Missing origin for origin reference (%s) (found in %os)", match, target)

    target = target.replace /^([^:]+):closest(?: (.+))?$/, (match, parentSelector, childSelector) ->
      if origin
        if parent = up.fragment.closest(origin, parentSelector)
          improvedParentSelector = toTarget(parent)
          if childSelector
            return improvedParentSelector + ' ' + childSelector
          else
            return improvedParentSelector
      else
        up.fail('Missing origin for pseudo-class :closest (found in %s)', target)

    if u.contains(target, ':closest')
      up.fail('The :closest pseudo-class must be in the first part of a selector sequence (found in %s)', target)

    return target

  up.on 'up:app:boot', ->
    body = document.body
    setSource(body, up.history.location)
    hello(body)

  up.on 'up:framework:reset', reset

  u.literal
    <% if ENV['JS_KNIFE'] %>knife: eval(Knife.point)<% end %>
    config: config
    replace: replace
    reload: reload
    destroy: destroy
    render: render
    extract: extract
    first: (args...) ->
      up.legacy.deprecated('up.fragment.get()', 'up.fragment.get()')
      getOne(args...)
    get: getOne
    all: getAll
    subtree: getSubtree
    closest: closest
    source: source
    setSource: setSource
    hello: hello
    visit: visit
    markAsDestroying: markFragmentAsDestroying
    emitInserted: emitFragmentInserted
    emitDestroyed: emitFragmentDestroyed
    emitKeep: emitFragmentKeep
    emitKept: emitFragmentKept
    successKey: successKey,
    failKey: failKey
    resolveTarget: resolveTarget
    toTarget: toTarget

up.replace = up.fragment.replace
up.extract = up.fragment.extract
up.reload = up.fragment.reload
up.destroy = up.fragment.destroy
up.render = up.fragment.render
up.hello = up.fragment.hello
up.visit = up.fragment.visit

up.first = (args...) ->
  up.legacy.deprecated('up.first()', 'up.fragment.get()')
  up.fragment.get(args...)

up.legacy.renamedModule 'flow', 'fragment'
up.legacy.renamedModule 'dom', 'fragment'
