###**
Linking to fragments
====================

The `up.link` module lets you build links that update fragments instead of entire pages.

\#\#\# Motivation

In a traditional web application, the entire page is destroyed and re-created when the
user follows a link:

![Traditional page flow](/images/tutorial/fragment_flow_vanilla.svg){:width="620" class="picture has_border is_sepia has_padding"}

This makes for an unfriendly experience:

- State changes caused by AJAX updates get lost during the page transition.
- Unsaved form changes get lost during the page transition.
- The JavaScript VM is reset during the page transition.
- If the page layout is composed from multiple scrollable containers
  (e.g. a pane view), the scroll positions get lost during the page transition.
- The user sees a "flash" as the browser loads and renders the new page,
  even if large portions of the old and new page are the same (navigation, layout, etc.).

Unpoly fixes this by letting you annotate links with an [`up-target`](/a-up-target)
attribute. The value of this attribute is a CSS selector that indicates which page
fragment to update. The server **still renders full HTML pages**, but we only use
the targeted fragments and discard the rest:

![Unpoly page flow](/images/tutorial/fragment_flow_unpoly.svg){:width="620" class="picture has_border is_sepia has_padding"}

With this model, following links feels smooth. All transient DOM changes outside the updated fragment are preserved.
Pages also load much faster since the DOM, CSS and Javascript environments do not need to be
destroyed and recreated for every request.


\#\#\# Example

Let's say we are rendering three pages with a tabbed navigation to switch between screens:

Your HTML could look like this:

```
<nav>
  <a href="/pages/a">A</a>
  <a href="/pages/b">B</a>
  <a href="/pages/b">C</a>
</nav>

<article>
  Page A
</article>
```

Since we only want to update the `<article>` tag, we annotate the links
with an `up-target` attribute:

```
<nav>
  <a href="/pages/a" up-target="article">A</a>
  <a href="/pages/b" up-target="article">B</a>
  <a href="/pages/b" up-target="article">C</a>
</nav>
```

Note that instead of `article` you can use any other CSS selector like `#main .article`.

With these [`up-target`](/a-up-target) annotations Unpoly only updates the targeted part of the screen.
The JavaScript environment will persist and the user will not see a white flash while the
new page is loading.

@module up.link
###

up.link = do ->

  u = up.util
  e = up.element

  preloadDelayTimer = undefined
  waitingLink = undefined
  preloadDelay = new up.LinkPreloadDelay()

  LINKS_WITH_REMOTE_CONTENT = ['a[href]', '[up-href]']
  LINKS_WITH_LOCAL_CONTENT = ['a[up-content]', 'a[up-inner]', 'a[up-outer]', 'a[up-document]'] # TODO: Replace [up-content] with [up-inner]
  LINKS_WITH_ANY_CONTENT = LINKS_WITH_REMOTE_CONTENT.concat(LINKS_WITH_LOCAL_CONTENT) # TODO: remove [up-content]
  ATTRIBUTES_SUGGESTING_FOLLOW = [e.trueAttributeSelector('up-follow'), '[up-target]', '[up-layer]', '[up-mode]', '[up-transition]']

  combineFollowableSelectors = (elementSelectors, attributeSelectors = ATTRIBUTES_SUGGESTING_FOLLOW) ->
    return u.flatMap(elementSelectors, (l) -> attributeSelectors.map((r) -> l + r))

  config = new up.Config ->
    preloadDelay: 75
    follow: combineFollowableSelectors(LINKS_WITH_ANY_CONTENT)
    instant: combineFollowableSelectors(LINKS_WITH_ANY_CONTENT, [e.trueAttributeSelector('up-instant')])
    preload: combineFollowableSelectors(LINKS_WITH_REMOTE_CONTENT, [e.trueAttributeSelector('up-preload')])

  fullFollowSelector = ->
    config.follow.join(',')

  fullPreloadSelector = ->
    config.preload.join(',')

  fullInstantSelector = ->
    config.instant.join(',')

  isInstant = (linkOrDescendant) ->
    !!e.closest(linkOrDescendant, fullInstantSelector())

  ###**
  @property up.link.config
  @param {number} [config.preloadDelay=75]
    The number of milliseconds to wait before [`[up-preload]`](/a-up-preload)
    starts preloading.
  ###
  reset = ->
    config.reset()
    preloadDelay.reset()

  ###**
  Fetches the given link's `[href]` with JavaScript and [replaces](/up.replace) the current page with HTML from the response.

  By default the page's `<body>` element will be replaced.
  If the link has an attribute like `a[up-target]`
  or `a[up-modal]`, the respective Unpoly behavior will be used.

  Emits the event `up:link:follow`.

  \#\#\# Examples

  Assume we have a link with an `a[up-target]` attribute:

      <a href="/users" up-target=".main">Users</a>

  Calling `up.follow()` with this link will replace the page's `.main` fragment
  as if the user had clicked on the link:

      var link = document.querySelector('a')
      up.follow(link)

  @function up.follow
  @param {Element|jQuery|string} linkOrSelector
    An element or selector which is either an `<a>` tag or any element with an `[up-href]` attribute.
  @param {string} [options.target]
    The selector to replace.

    Defaults to the link's `[up-target]`, `[up-modal]` or `[up-popup]` attribute.
    If no target is given, the `<body>` element will be replaced.
  @param {String} [options.url]
    The URL to navigate to.

    Defaults to the link's `[up-href]` or `[href]` attribute.
  @param {boolean|string} [options.reveal=true]
    Whether to [reveal](/up.reveal) the target fragment after it was replaced.

    You can also pass a CSS selector for the element to reveal.
  @param {boolean|string} [options.failReveal=true]
    Whether to [reveal](/up.reveal) the target fragment when the server responds with an error.

    You can also pass a CSS selector for the element to reveal.
  @return {Promise}
    A promise that will be fulfilled when the link destination
    has been loaded and rendered.
  @stable
  ###
  follow = (link, options) ->
    # If passed a selector, up.fragment.get() will prefer a match on the current layer.
    link = up.fragment.get(link)
    options = u.options(options)

    # TODO: Document new follow options like onOpened, [up-on-opened], ...
    parser = new up.OptionParser(options, link, fail: true)

    # Request options
    parser.string('url', attr: ['up-href', 'href'])
    options.method = followMethod(link, options)
    parser.json('headers')
    parser.json('params')
    parser.boolean('cache')
    parser.boolean('solo')
    parser.boolean('tentative')

    # Feedback options
    parser.boolean('feedback')

    # Fragment options
    parser.string('failOptions')
    parser.options.origin ?= parser.element
    parser.boolean('navigate')
    parser.string('confirm')
    parser.string('target')
    parser.booleanOrString('fallback')
    parser.parse(((link, attrName) -> e.callbackAttr(link, attrName, ['request', 'response', 'change'])), 'onLoaded')
    parser.string('content')
    parser.string('html')

    # Layer options
    parser.string('layer')
    parser.string('mode') # Renamed to { close }. Legacy calls handled by up.Change.OpenLayer.
    parser.string('mode')
    parser.json('context')
    parser.boolean('peel')
    parser.string('align')
    parser.string('position')
    parser.string('class')
    parser.string('size')
    parser.boolean('closable') # Renamed to { closable }. Legacy calls handled by up.Change.OpenLayer.
    parser.boolean('dismissable')
    parser.boolean('buttonDismissable')
    parser.boolean('escapeDismissable')
    parser.boolean('outsideDismissable')
    parser.parse(up.layer.openCallbackAttr, 'onOpening')
    parser.parse(up.layer.openCallbackAttr, 'onOpened')
    parser.parse(up.layer.closeCallbackAttr, 'onAccept')
    parser.parse(up.layer.closeCallbackAttr, 'onAccepting')
    parser.parse(up.layer.closeCallbackAttr, 'onAccepted')
    parser.parse(up.layer.closeCallbackAttr, 'onDismiss')
    parser.parse(up.layer.closeCallbackAttr, 'onDismissing')
    parser.parse(up.layer.closeCallbackAttr, 'onDismissed')
    parser.string('acceptEvent')
    parser.string('dismissEvent')
    parser.string('acceptLocation')
    parser.string('dismissLocation')

    # Viewport options
    parser.booleanOrString('reveal')
    parser.booleanOrString('focus')
    parser.boolean('resetScroll')
    parser.boolean('restoreScroll')

    # History options
    # { history } is actually a boolean, but we keep the deprecated string
    # variant which should now be passed as { location }.
    parser.booleanOrString('history')
    parser.booleanOrString('location')
    parser.booleanOrString('title')

    # Motion options
    parser.booleanOrString('animation')
    parser.booleanOrString('transition')
    parser.string('easing')
    parser.number('duration')

    # This is the event that may be prevented to stop the follow.
    # up.form.submit() changes this to be up:form:submit instead.
    # The guardEvent will also be assigned an { options } attribute in up.change()
    options.guardEvent ||= up.event.build('up:link:follow', log: 'Following link')

    return up.change(options)

  ###**
  This event is [emitted](/up.emit) when a link is [followed](/up.follow) through Unpoly.

  The event is emitted on the `<a>` element that is being followed.

  @event up:link:follow
  @param {Element} event.target
    The link element that will be followed.
  @param event.preventDefault()
    Event listeners may call this method to prevent the link from being followed.
  @stable
  ###

  ###**
  Preloads the given link.

  When the link is clicked later, the response will already be cached,
  making the interaction feel instant.

  @function up.link.preload
  @param {string|Element|jQuery} link
    The element or selector whose destination should be preloaded.
  @param {Object} options
    See options for `up.follow()`.
  @return
    A promise that will be fulfilled when the request was loaded and cached
  @experimental
  ###
  preload = (link, options) ->
    # If passed a selector, up.fragment.get() will prefer a match on the current layer.
    link = up.fragment.get(link)

    unless isSafe(link)
      return up.error.failed.async("Won't preload unsafe link")

    unless e.matches(link, '[href], [up-href]')
      return up.error.failed.async("Won't preload link without a URL")

    guardEvent = up.event.build('up:link:preload', log: ['Preloading link %o', link])
    follow(link, u.merge(options, preload: true, { guardEvent }))

  ###**
  This event is [emitted](/up.emit) before a link is [preloaded](/up.preload).

  @event up:link:preload
  @param {Element} event.target
    The link element that will be preloaded.
  @param event.preventDefault()
    Event listeners may call this method to prevent the link from being preloaded.
  @stable
  ###

  ###**
  Returns the HTTP method that should be used when following the given link.

  Looks at the link's `up-method` or `data-method` attribute.
  Defaults to `"get"`.

  @function up.link.followMethod
  @param link
  @param options.method {string}
  @internal
  ###
  followMethod = (link, options = {}) ->
    u.normalizeMethod(options.method || link.getAttribute('up-method') || link.getAttribute('data-method'))

  ###**
  Returns whether the given link will be [followed](/up.follow) by Unpoly
  instead of making a full page load.

  A link will be followed by Unpoly if it has an attribute
  like `a[up-target]` or `a[up-modal]`.

  @function up.link.isFollowable
  @param {Element|jQuery|string} linkOrSelector
    The link to check.
  @experimental
  ###
  isFollowable = (linkOrSelector) ->
    # If passed a selector, up.fragment.get() will prefer a match on the current layer.
    link = up.fragment.get(linkOrSelector)
    e.matches(link, fullFollowSelector())

  ###**
  Makes sure that the given link will be [followed](/up.follow)
  by Unpoly instead of making a full page load.

  This is done by giving the link an `a[up-follow]` attribute
  unless it already have it an attribute like `a[up-target]` or `a[up-modal]`.

  @function up.link.makeFollowable
  @param {Element|jQuery|string} linkOrSelector
    The link to process.
  @experimental
  ###
  makeFollowable = (link) ->
    unless isFollowable(link)
      link.setAttribute('up-follow', '')

  shouldFollowEvent = (event, link) ->
    # We never handle events for the right mouse button, or when Shift/CTRL/Meta is pressed
    return false unless up.event.isUnmodifiedMouseEvent(event)

    # If user clicked on a child link of $link, or in an <input> within an [up-expand][up-href]
    # we want those other elements handle the click.
    betterTargetSelector = "a, [up-href], #{up.form.fieldSelector()}"
    betterTarget = e.closest(event.target, betterTargetSelector)
    return !betterTarget || betterTarget == link

  ###**
  Provide an up:click event that improves on standard click
  in several ways:

  - It is emitted on mousedown for [up-instant] elements
  - It is not emitted if the element has disappeared (or was overshadowed)
    between mousedown and click. This can happen if mousedown creates a layer
    over the element, or if a mousedown handler removes a handler.

  Stopping an up:click event will also stop the underlying event.

  @function up.link.convertClicks
  @param {up.Layer} layer
  ###
  convertClicks = (layer) ->
    layer.on 'click', (event, element) ->
      # Instant links should not have a `click` event.
      # This would trigger the browsers default follow-behavior and possibly activate JS libs.
      # A11Y: We also need to check whether the [up-instant] behavior did trigger on mousedown.
      # Keyboard navigation will not necessarily trigger a mousedown event.
      if isInstant(element) && element.upInstantSupported
        up.event.halt(event)
        element.upInstantSupported = false

      # In case mousedown has created a layer over the click coordinates,
      # Chrome will emit an event with { target: document.body } on click.
      # Ignore that event and only process if we would still hit the
      # expect layers at the click coordinates.
      else if layer.wasHitByMouseEvent(event)
        convertClick(event)

    layer.on 'mousedown', (event, element) ->
      if isInstant(element)
        # A11Y: Keyboard navigation will not necessarily trigger a mousedown event.
        # We also don't want to listen to the enter key, since some screen readers
        # use the enter key for something else.
        element.upInstantSupported = true
        convertClick(event)

  convertClick = (originalEvent) ->
    copiedKeys = ['clientX', 'clientY', 'button', 'metaKey', 'shiftKey', 'ctrlKey']
    forwardedKeys = ['stopPropagation', 'stopImmediatePropagation', 'preventDefault']

    newEvent = up.event.build('up:click', u.pick(originalEvent, copiedKeys))
    newEvent.originalEvent = originalEvent # allow users to access other props through event.originalEvent.prop

    forwardedKeys.forEach (key) ->
      originalMethod = newEvent[key]

      newEvent[key] = ->
        originalEvent[key]()
        return originalMethod.call(newEvent)

    up.emit(originalEvent.target, newEvent, log: false)

  ###**
  Returns whether the given link has a [safe](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1)
  HTTP method like `GET`.

  @function up.link.isSafe
  @experimental
  ###
  isSafe = (selectorOrLink, options) ->
    method = followMethod(selectorOrLink, options)
    up.proxy.isSafeMethod(method)

  targetMacro = (queryAttr, fixedResultAttrs, callback) ->
    up.macro "[#{queryAttr}]", (link) ->
      optionalTarget = link.getAttribute(queryAttr)
      resultAttrs = u.merge(fixedResultAttrs, 'up-target': optionalTarget)
      e.setMissingAttrs(link, resultAttrs)
      link.removeAttribute(queryAttr)
      callback?()

  ###**
  [Follows](/up.follow) this link with JavaScript and replaces a CSS selector
  on the current page with a corresponding element from the response.

  \#\#\# Example

  This will update the fragment `<div class="main">` with the same element
  fetched from `/posts/5`:

      <a href="/posts/5" up-target=".main">Read post</a>

  \#\#\# Updating multiple fragments

  You can update multiple fragments from a single request by separating
  separators with a comma (like in CSS).

  For instance, if opening a post should
  also update a bubble showing the number of unread posts, you might
  do this:

      <a href="/posts/5" up-target=".main, .unread-count">Read post</a>

  \#\#\# Appending or prepending content

  By default Unpoly will replace the given selector with the same
  selector from the server response. Instead of replacing you
  can *append* the loaded content to the existing content by using the
  `:after` pseudo selector. In the same fashion, you can use `:before`
  to indicate that you would like the *prepend* the loaded content.

  A practical example would be a paginated list of items. Below the list is
  a button to load the next page. You can append to the existing list
  by using `:after` in the `up-target` selector like this:

      <ul class="tasks">
        <li>Wash car</li>
        <li>Purchase supplies</li>
        <li>Fix tent</li>
      </ul>

      <a href="/page/2" class="next-page" up-target=".tasks:after, .next-page">
        Load more tasks
      </a>

  \#\#\# Following elements that are no links

  You can also use `[up-target]` to turn an arbitrary element into a link.
  In this case, put the link's destination into the `[up-href]` attribute:

      <button up-target=".main" up-href="/foo/bar">Go</button>

  Note that using any element other than `<a>` will prevent users from
  opening the destination in a new tab.

  @selector a[up-target]
  @param {string} up-target
    The CSS selector to replace

    Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).
  @param {string} [up-method='get']
    The HTTP method to use for the request.
  @param {string} [up-transition='none']
    The [transition](/up.motion) to use for morphing between the old and new elements.
  @param [up-fail-target='body']
    The CSS selector to replace if the server responds with an error.

    Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).
  @param {string} [up-fail-transition='none']
    The [transition](/up.motion) to use for morphing between the old and new elements
    when the server responds with an error.
  @param {string} [up-fallback]
    The selector to update when the original target was not found in the page.
  @param {string} [up-href]
    The destination URL to follow.
    If omitted, the the link's `href` attribute will be used.
  @param {string} [up-confirm]
    A message that will be displayed in a cancelable confirmation dialog
    before the link is followed.
  @param {string} [up-reveal='true']
    Whether to reveal the target element after it was replaced.

    You can also pass a CSS selector for the element to reveal.
    Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).
  @param {string} [up-fail-reveal='true']
    Whether to reveal the target element when the server responds with an error.

    You can also pass a CSS selector for the element to reveal.
    Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).
  @param {string} [up-restore-scroll='false']
    Whether to restore previously known scroll position of all viewports
    within the target selector.
  @param {string} [up-cache]
    Whether to force the use of a cached response (`true`)
    or never use the cache (`false`)
    or make an educated guess (default).
  @param {string} [up-layer='auto']
    The name of the layer that ought to be updated. Valid values are
    `'auto'`, `'page'`, `'modal'` and `'popup'`.

    If set to `'auto'` (default), Unpoly will try to find a match in the link's layer.
    If no match was found in that layer,
    Unpoly will search in other layers, starting from the topmost layer.
  @param {string} [up-fail-layer='auto']
    The name of the layer that ought to be updated if the server sends a
    non-200 status code.
  @param [up-history]
    Whether to push an entry to the browser history when following the link.

    Set this to `'false'` to prevent the URL bar from being updated.
    Set this to a URL string to update the history with the given URL.
  @stable
  ###

  ###**
  Fetches this link's `[href]` with JavaScript and [replaces](/up.replace) the
  current `<body>` element with the response's `<body>` element.

  To only update a fragment instead of the entire `<body>`, see `a[up-target]`.

  \#\#\# Example

      <a href="/users" up-follow>User list</a>

  \#\#\# Turn any element into a link

  You can also use `[up-follow]` to turn an arbitrary element into a link.
  In this case, put the link's destination into the `up-href` attribute:

      <span up-follow up-href="/foo/bar">Go</span>

  Note that using any element other than `<a>` will prevent users from
  opening the destination in a new tab.

  @selector a[up-follow]

  @param {string} [up-method='get']
    The HTTP method to use for the request.
  @param [up-fail-target='body']
    The selector to replace if the server responds with an error.
  @param {string} [up-fallback]
    The selector to update when the original target was not found in the page.
  @param {string} [up-transition='none']
    The [transition](/up.motion) to use for morphing between the old and new elements.
  @param {string} [up-fail-transition='none']
    The [transition](/up.motion) to use for morphing between the old and new elements
    when the server responds with an error.
  @param [up-href]
    The destination URL to follow.
    If omitted, the the link's `href` attribute will be used.
  @param {string} [up-confirm]
    A message that will be displayed in a cancelable confirmation dialog
    before the link is followed.
  @param {string} [up-history]
    Whether to push an entry to the browser history when following the link.

    Set this to `'false'` to prevent the URL bar from being updated.
    Set this to a URL string to update the history with the given URL.
  @param [up-restore-scroll='false']
    Whether to restore the scroll position of all viewports
    within the response.
  @stable
  ###
  up.on 'up:click', fullFollowSelector, (event, link) ->
    if shouldFollowEvent(event, link)
      up.event.halt(event)
      u.muteRejection follow(link)

  ###**
  By adding an `up-instant` attribute to a link, the destination will be
  fetched on `mousedown` instead of `click` (`mouseup`).

      <a href="/users" up-target=".main" up-instant>User list</a>

  This will save precious milliseconds that otherwise spent
  on waiting for the user to release the mouse button. Since an
  AJAX request will be triggered right way, the interaction will
  appear faster.

  Note that using `[up-instant]` will prevent a user from canceling a
  click by moving the mouse away from the link. However, for
  navigation actions this isn't needed. E.g. popular operation
  systems switch tabs on `mousedown` instead of `click`.

  `[up-instant]` will also work for links that open [modals](/up.modal) or [popups](/up.popup).

  @selector a[up-instant]
  @stable
  ###

  ###**
  [Follows](/up.follow) this link *as fast as possible*.

  This is done by:

  - [Following the link through AJAX](/a-up-target) instead of a full page load
  - [Preloading the link's destination URL](/a-up-preload)
  - [Triggering the link on `mousedown`](/a-up-instant) instead of on `click`

  \#\#\# Example

  Use `up-dash` like this:

      <a href="/users" up-dash=".main">User list</a>

  This is shorthand for:

      <a href="/users" up-target=".main" up-instant up-preload>User list</a>

  @selector a[up-dash]
  @param {string} [up-dash='body']
    The CSS selector to replace

    Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).
  @stable
  ###
  targetMacro 'up-dash', { 'up-preload': '', 'up-instant': '' }

  ###**
  Add an `[up-expand]` attribute to any element to enlarge the click area of a
  descendant link.

  `[up-expand]` honors all the Unppoly attributes in expanded links, like
  `a[up-target]`, `a[up-instant]` or `a[up-preload]`.
  It also expands links that open [modals](/up.modal) or [popups](/up.popup).

  \#\#\# Example

      <div class="notification" up-expand>
        Record was saved!
        <a href="/records">Close</a>
      </div>

  In the example above, clicking anywhere within `.notification` element
  would [follow](/up.follow) the *Close* link.

  \#\#\# Elements with multiple contained links

  If a container contains more than one link, you can set the value of the
  `up-expand` attribute to a CSS selector to define which link should be expanded:

      <div class="notification" up-expand=".close">
        Record was saved!
        <a class="details" href="/records/5">Details</a>
        <a class="close" href="/records">Close</a>
      </div>

  \#\#\# Limitations

  `[up-expand]` has some limitations for advanced browser users:

  - Users won't be able to right-click the expanded area to open a context menu
  - Users won't be able to `CTRL`+click the expanded area to open a new tab

  To overcome these limitations, consider nesting the entire clickable area in an actual `<a>` tag.
  [It's OK to put block elements inside an anchor tag](https://makandracards.com/makandra/43549-it-s-ok-to-put-block-elements-inside-an-a-tag).

  @selector [up-expand]
  @param {string} [up-expand]
    A CSS selector that defines which containing link should be expanded.

    If omitted, the first link in this element will be expanded.
  @stable
  ###
  up.macro '[up-expand]', (area) ->
    selector = area.getAttribute('up-expand') || 'a, [up-href]'

    if childLink = e.get(area, selector)
      areaAttrs = e.upAttrs(childLink)
      areaAttrs['up-href'] ||= childLink.getAttribute('href')
      e.setMissingAttrs(area, areaAttrs)
      makeFollowable(area)

  ###**
  Links with an `up-preload` attribute will silently fetch their target
  when the user hovers over the click area, or when the user puts her
  mouse/finger down (before releasing).

  When the link is clicked later, the response will already be cached,
  making the interaction feel instant.

  @selector a[up-preload]
  @param [up-delay=75]
    The number of milliseconds to wait between hovering
    and preloading. Increasing this will lower the load in your server,
    but will also make the interaction feel less instant.
  @stable
  ###
  up.compiler fullPreloadSelector, (link) ->
    preloadDelay.observeLink(link)

  up.on 'up:framework:reset', reset

  <% if ENV['JS_KNIFE'] %>knife: eval(Knife.point)<% end %>
  follow: follow
  preload: preload
  makeFollowable: makeFollowable
  isSafe: isSafe
  isFollowable: isFollowable
  shouldFollowEvent: shouldFollowEvent
  followMethod: followMethod
  targetMacro: targetMacro
  convertClicks: convertClicks
  config: config
  combineFollowableSelectors: combineFollowableSelectors

up.follow = up.link.follow
