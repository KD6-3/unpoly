u = up.util
e = up.element

up.layer = do ->

  OVERLAY_CLASSES = [
    up.Layer.Modal
    up.Layer.Popup
    up.Layer.Drawer
    up.Layer.Cover
  ]
  OVERLAY_MODES = u.map(OVERLAY_CLASSES, 'mode')
  LAYER_CLASSES = [up.Layer.Root].concat(OVERLAY_CLASSES)

  # TODO: Document up.layer.config
  config = new up.Config ->
    newConfig =
      mode: 'modal'
      all:
        # Define a default target that will close all overlays
        # and show an unpexpected response in the <body>
        targets: [{ layer: 'root', target: 'body', peel: true }]
      root:
        targets: []
      overlay:
        targets: []
        history: true
        openAnimation: 'fade-in'
        closeAnimation: 'fade-out'
        dismissLabel: 'Ã—'
        dismissAriaLabel: 'Dismiss dialog'
        dismissable: true
      cover:
        targets: []
      drawer:
        targets: []
        backdrop: true
        position: 'left'
        openAnimation: (layer) ->
          switch layer.position
            when 'left' then 'move-from-left'
            when 'right' then 'move-from-right'
        closeAnimation: (layer) ->
          switch layer.position
            when 'left' then 'move-to-left'
            when 'right' then 'move-to-right'
      modal:
        backdrop: true
        targets: []
      popup:
        targets: []
        position: 'bottom'
        align: 'left'
        history: false

    for Class in LAYER_CLASSES
      newConfig[Class.mode].Class = Class

    return newConfig

  stack = null

  handlers = []

  isOverlayMode = (mode) ->
    return u.contains(OVERLAY_MODES, mode)

  defaultTargets = (mode) ->
    return u.flatMap(modeConfigs(mode), 'targets')

  ###**
  Returns an array of config objects that apply to the given mode name.

  The config objects are in descending order of specificity.
  ###
  modeConfigs = (mode) ->
    if mode == 'root'
      return [config.root, config.all]
    else
      return [config[mode], config.overlay, config.all]
      
  normalizeOptions = (options) ->
    up.legacy.fixKey(options, 'closable', 'dismissable')
    up.legacy.fixKey(options, 'flavor', 'mode')

    if options.layer
      if options.layer == 'swap'
        if up.layer.isRoot()
          options.layer = 'root'
        else
          options.layer = 'new'
          options.base = 'parent'

      if options.layer == 'new'
        # If the user wants to open a new layer, but does not pass a { mode },
        # we assume the default mode from up.layer.config.mode.
        options.mode ||= config.mode
      else if isOverlayMode(options.layer)
        # We allow passing an overlay mode in { layer }, which will
        # open a new layer with that mode.
        options.mode = options.layer
        options.layer = 'new'
      else if options.layer == 'page'
        up.legacy.warn('Layer "page" has been renamed to "root"')
        options.layer = 'root'
    else
      # If no options.layer is given we still want to avoid updating "any" layer.
      # Other options might have a hint for a more appropriate layer.

      if options.mode
        # If user passes a { mode } option without a { layer } option
        # we assume they want to open a new layer.
        options.layer = 'new'
      else if u.isElementish(options.target)
        # If we are targeting an actual Element or jQuery collection (and not
        # a selector string) we operate in that element's layer.
        options.layer = stack.get(options.target, normalizeLayerOptions: false)
      else if options.origin
        # Links update their own layer by default.
        options.layer = 'origin'
      else
        # If nothing is given, we allow changes of any layer (preferring the current layer)
        options.layer = 'any'

    options.context ||= {}

    # Remember the layer that was current when the request was made,
    # so changes with `{ layer: 'new' }` will know what to stack on.
    # Note if options.base is given, up.layer.get('current', options) will
    # return the resolved version of that.
    # TODO: Test this
    options.base = stack.get('current', u.merge(options, normalizeLayerOptions: false))

  build = (options) ->
    mode = options.mode
    Class = config[mode].Class
    configs = u.reverse(modeConfigs(mode))
    options = u.mergeDefined(configs..., { mode, stack }, options)
    return new Class(options)

#  modeClass = (options = {}) ->
#    mode = options.mode ? config.mode
#    config[mode].Class or up.fail("Unknown layer mode: #{mode}")

  openCallbackAttr = (link, attr) ->
    if code = link.getAttribute(attr)
      # Emulate the behavior of the `onclick` attribute,
      # where `this` refers to the clicked element.
      new Function('event', code).bind(link)

  closeCallbackAttr = (link, attr) ->
    if code = link.getAttribute(attr)
      # Allow callbacks to refer to `value` directly instead of through `event.value`.
      callback = new Function('event', 'value', code)
      # Emulate the behavior of the `onclick` attribute,
      # where `this` refers to the clicked element.
      return (event) -> callback.call(link, event, event.value)

  reset = ->
    config.reset()
    stack.reset()
    handlers = u.filter(handlers, 'isDefault')

  open = (options) ->
    options = u.options(options, layer: 'new')

    # Even if we are given { content } we need to pipe this through up.change()
    # since a lot of options processing is happening there.
    return up.change(options)

  # TODO: Docs for up.layer.ask()
  ask = (options) ->
    return new Promise (resolve, reject) ->
      options = u.merge options,
        onAccepted: (event) -> resolve(event.value)
        onRejected: (event) -> reject(event.value)
      open(options)

  allElements = (selector, options) ->
    layers = stack.list(options)
    u.flatMap layers, (layer) -> layer.allElements(selector)

  firstElement = (selector, options) ->
    layers = stack.list(options)
    u.findResult layers, -> layer.firstElement(selector)

  ###**
  # Event handlers for [up-target] etc. are registered to each layer instead of
  # only once to the document. See https://github.com/unpoly/unpoly/issues/79
  #
  # @function up.layer.onEach
  # @internal
  ###
  registerHandler = (handler...) ->
    handler.isDefault = up.framework.isBooting()

    # Remember handler for future layers
    handlers.push(handler)

    # Apply to existing layers
    for layer in stack.layers
      layer.on(handler...)

  applyHandlers = (layer) ->
    for handler in handlers
      layer.on(handler...)

  up.event.onEscape (event) ->
    layer = stack.current
    if layer.escapeDismissable
      u.muteRejection layer.dismiss()
      up.event.halt(event)

  registerCloseHandler = (attribute, closeFn) ->
    # Allow the fallbacks to be both vanilla links and Unpoly [up-target] links
    registerHandler 'click up:link:follow', "[#{attribute}]", (event) ->
      origin = event.target
      layer = stack.get(origin)
      # To make a view usable both as a root layer and as an overlay, the programmer might
      # define a fallback like this:
      #
      #     <a href="/fallback" up-accept>...</a>
      #
      # We only want to accept the layer (and halt the event chain) if that link is in an overlay.
      # If the link is in the root layer, we allow the event to bubble up.
      unless layer.isRoot()
        value = e.jsonAttr(origin, attribute)
        # u.muteRejection closeFn(layer, { value, origin })
        closeFn(layer, { value, origin })
        up.event.halt(event)

  up.on 'up:framework:boot', ->
    stack = new up.LayerStack()

    registerCloseHandler 'up-accept', (layer, closeOptions) ->
      return layer.accept(closeOptions)

    registerCloseHandler 'up-dismiss', (layer, closeOptions) ->
      return layer.dismiss(closeOptions)

    registerCloseHandler 'up-close', (layer, closeOptions) ->
      up.legacy.deprecated('[up-close]', '[up-dismiss]')
      return layer.dismiss(closeOptions)

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  u.literal
    get: (args...) -> stack.get(args...)
    list: (args...) -> stack.list(args...)
    attachAll: -> stack.attach()
    allElements: allElements
    firstElement: firstElement
    config: config
    defaultTargets: defaultTargets
    open: open
    build: build
    normalizeOptions: normalizeOptions
    accept: (args...) -> stack.current.accept(args...)
    dismiss: (args...) -> stack.current.dismiss(args...)
    sync: (args...) -> stack.current.sync(args...)
    openCallbackAttr: openCallbackAttr
    closeCallbackAttr: closeCallbackAttr
    isRoot: -> stack.isRoot()
    isOverlay: -> stack.isOverlay()
    push: (args...) -> stack.push(args...)
    isOverlayMode: isOverlayMode
    on: (args...) -> stack.current.on(args...)
    off: (args...) -> stack.current.off(args...)
    emit: (args...) -> stack.current.emit(args...)
    onEach: registerHandler
    applyHandlers: applyHandlers
    get_root: -> stack.root
    get_all: -> stack.layers
    get_current: -> stack.current
    get_front: -> stack.front
    get_parent: -> stack.current.parent
    parentOf: (args...) -> stack.parentOf(args...)
    get_location: -> stack.current.location
    get_history: -> stack.current.history
    get_title: -> stack.current.title
    get_mode: -> stack.current.mode
    get_position: -> stack.current.position
    get_element: -> stack.current.element
    get_context: -> stack.current.context
    contains: (args...) -> stack.current.contains(args...)
